---
description: >
  Cursor rules for the HeatControl project (ESP32-C3 temperature controller, web UI + HTTP endpoints).
  These rules apply to all AI-assisted edits in this repo.
globs:
  - "**/*"
alwaysApply: true
---

This project is a dual-zone temperature controller (HeatControl) for heating control (e.g. drysuit diving). This codebase (HeatController) may target ESP32-C3 or Wemos D1 Mini; hardware details, pinout, and use case are documented in the references below.
It uses OneWire/Dallas (DS18B20) temperature sensors, MOSFET/SSR outputs for heating, WiFi (AP + captive portal), EEPROM for persistent settings, and a web UI. Operating modes: Normal (temperature-based control) and Boost/Power (full power, e.g. via GPIO or restart with mode=power).

Project information and references (check for hardware, features, and conventions):
- GitHub: https://github.com/BubTec/HeatControl
- Blog: https://bubtec.de/2024/11/10/heatcontrol/

Core project rules
- The code and comments are always in English.
- The project is licensed under GPL-3.0; respect it when adding dependencies or code.
- Always prefer small, isolated changes over large refactorings.
- For any non-trivial change, perform a full rebuild using PlatformIO.
- Follow the existing coding style; if .clang-format, .clang-tidy, or .cpplint exist, adhere to them.
- Respect the existing module boundaries in src/ and test/.

Web server and endpoint rules
- The device exposes HTTP endpoints (e.g. /, /status, /setTemp, /swapSensors, /setWiFi, /restart, /resetRuntime) and serves a web UI. Default AP IP is 4.3.2.1 when documented in the repo.
- Temperature thresholds: use the project range (e.g. 10-45°C per README) for validation when handling /setTemp or similar.
- If you add or change HTTP endpoints or their request/response behaviour:
  - Keep any existing API or endpoint documentation in sync (e.g. api-specification.yaml if introduced later).
  - If the project later maintains an OpenAPI file (api-specification.yaml), update paths, schemas, and examples when changing endpoints.
- When changing JSON or response structures of any endpoint, update corresponding tests and any spec file if present.

Logging rules
- If you add or extend serial logging:
  - Use the existing logging/serial output helpers used in the project instead of ad-hoc Serial.print() where applicable.
  - Keep log messages concise and in English.
  - Avoid logging sensitive information (e.g. WiFi passwords, calibration data that should not be exposed).

Testing and automation rules
- This project uses PlatformIO tests (see test/ and README).
- When any file under src/ or test/ is modified:
  - Run at least: `python -m platformio test -e native` (or the appropriate env, e.g. esp32-c3, if tests are set up for it).
  - If run_all_tests.ps1 exists in the repo root, prefer it for larger or cross-cutting changes.
  - When a shell/terminal is available, run these commands yourself rather than only suggesting them.
  - If tests fail, analyse and fix before making further changes.
  - Do not propose a commit until all tests pass.
- Never ask the user whether tests should be run; assume they must be executed.
- When fixing a bug:
  - Check whether a test already covers it; if not, add a test that reproduces the bug and verifies the fix.

API / endpoint test coverage rules
- When modifying HTTP endpoints (e.g. /status, /setTemp, /setWiFi, etc.):
  - Ensure there is at least one dedicated test under test/ that exercises the endpoint where feasible (e.g. on native env).
  - If an API test module exists, extend it; otherwise create one following existing test structure and naming.
  - Tests should cover at least one success case (valid input, expected response/status) and one error or boundary case.
  - If response is JSON, validate required fields and value types (and ranges/enums where applicable).
- If you change the JSON or response structure of an endpoint, update the corresponding tests and any api-specification.yaml if present.

Mock and hardware abstraction rules
- The project controls real hardware (DS18B20 temperature sensors, MOSFET/SSR heating outputs, WiFi, EEPROM). Heating outputs may use inverted logic (e.g. GPIO LOW = on); keep this consistent when changing pin handling.
- Tests must not depend on real hardware.
- When adding new hardware-dependent functionality in src/:
  - Follow existing patterns for hardware abstraction and mocking in test/ (e.g. mock_* headers or a central mock implementation).
  - Add or extend mocks under test/ so unit tests can simulate the new behaviour.
- When modifying existing hardware interaction code:
  - Keep hardware-specific code in dedicated modules (e.g. temperature reading, SSR control, WiFi/EEPROM), not mixed with business logic or request handlers.
  - Update mocks in test/ so existing tests reflect the new behaviour.

Test structure rules
- When adding new tests:
  - Place them in the appropriate subdirectory under test/ according to existing structure (e.g. by domain: API, temperature, wifi, etc.).
  - Use proper setup/teardown for shared state (e.g. global controller, mocks).
  - Use the Unity test framework conventions used by PlatformIO (TEST_SETUP, TEST_TEAR_DOWN, etc.) and existing naming (e.g. test_<module>.cpp, test_<feature>_<behaviour>).
- Tests must be deterministic: no reliance on real time, random values, or external network/hardware; use mocks or injected clocks if timing matters.

Build and tooling rules
- The primary build system is PlatformIO (see platformio.ini).
- For significant changes (endpoints, core control logic, hardware abstraction), perform a full rebuild with PlatformIO before suggesting a commit.
- If lint-check.ps1 or check.cppcheck (or similar) exist in the repo root, keep code compatible with them; fix formatting/lint issues introduced by your changes.

Web UI and embedded content rules
- The web UI is currently built from inline PROGMEM strings in src/ (e.g. index_html_p1 …). If the project later moves HTML/CSS/JS to a separate directory (e.g. upload/) and uses an embed script (e.g. embed_webfiles.py) to generate headers in src/generated/:
  - Run the embed script after changing web files and do not edit generated files manually.
  - Perform a full rebuild after regenerating embedded content.

Git and commit message rules
- For every logical change, propose a single, clear English commit message in the chat.
- Commit messages should be in imperative mood, describe code and test changes if any, and mention "API" or "endpoints" in the subject if HTTP-visible behaviour changed.
- Never run git commit, git push, git pull, or modify Git configuration/branches from tools; only propose commit messages. Do not bundle unrelated changes into one commit.

Continuous improvement of these rules
- If you learn something that should be enforced systematically (e.g. a new invariant, problematic pattern, or test requirement), propose an update to this rules file in the chat for the user to adopt.
